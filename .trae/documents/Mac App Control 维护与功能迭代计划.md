## 问题定位（已确认根因）
- 目前 Rust 侧 `get_installed_apps` 有进程内缓存 `APP_CACHE`，只要前端不传 `refresh: true` 就直接返回缓存。
- 你把某个 App 卸载后，缓存不会自动失效，因此前端仍能搜到；点击启动时 `launch_app` 用 `open <path>`，对不存在路径不会给前端报错，所以看起来就是“虚假应用”。

## 目标行为（修复标准）
- 卸载/移动应用后：列表里不再出现该条目；如果还没刷新时点到了，也能立刻提示并从列表移除。

## 实施方案（最小改动、性能可控）
1) 后端：缓存返回前做“存在性校验”并自动剔除
- 当 `APP_CACHE` 非空且 `refresh != true`：遍历缓存，用 `Path::exists()` 过滤掉已不存在的 app path。
- 如果有剔除：更新缓存并返回剔除后的结果；这样无需全量 `mdfind`，只做轻量 `stat`。

2) 后端：启动前检查路径并把错误返回给前端
- 把 `launch_app` 改成返回 `Result<(), String>`：若路径不存在则 `Err("App not found")`，并且不再递增 usage_count。

3) 前端：启动失败时自动清理并刷新列表
- `launchApp()` 捕获 `invoke('launch_app')` 的异常：
  - 立刻从本地 `apps` state 移除该条目（避免继续出现）。
  - 调用 `loadApps(false)` 触发后端缓存剔除（不做全量扫描）。

## 验证用例
- 打开应用 → 确认能看到目标 App → 去 Finder 删除/卸载 → 回到应用搜索：
  - 情况 A：不触发任何刷新操作，点击该条目：应提示/静默移除并刷新列表。
  - 情况 B：触发一次 `loadApps(false)`（比如点击失败后自动触发）：列表里不再出现该条目。

确认这个计划后，我会直接落地改动（`src-tauri/src/lib.rs` + `src/App.tsx`），并按上述用例验证。